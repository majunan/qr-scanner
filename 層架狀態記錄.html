<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>å±¤æ¶ç‹€æ…‹è¨˜éŒ„ (æ”¯æ´æ‹ç…§ã€å¡—é´‰èˆ‡å‚™è¨»)</title>
  <script src="https://unpkg.com/@zxing/library@0.19.1"></script>
  <style>
    /* --- é€šç”¨æ¨£å¼èˆ‡éŸ¿æ‡‰å¼åŸºç¤ --- */
    body {
      font-family: sans-serif;
      padding: 10px; /* æ¸›å°‘æ‰‹æ©Ÿé‚Šè· */
      margin: 0 auto; /* å…§å®¹å±…ä¸­ */
      max-width: 650px; /* é™åˆ¶å…§å®¹æœ€å¤§å¯¬åº¦ï¼Œé¿å…æ¡Œé¢ç‰ˆéå¯¬ */
      line-height: 1.6;
      color: #333;
    }

    h1, h2 {
      margin-top: 20px;
      color: #2c3e50;
    }

    /* --- è§¸æ§å‹å–„æŒ‰éˆ• --- */
    button {
      margin: 5px;
      padding: 10px 15px; /* å¢åŠ å…§è·ï¼Œè®“æŒ‰éˆ•æ›´å¤§ */
      font-size: 1.1em; /* ç¨å¾®æ”¾å¤§å­—é«” */
      cursor: pointer;
      border: 1px solid #ccc;
      border-radius: 4px;
      transition: background-color 0.2s, border-color 0.2s;
      flex-shrink: 0; /* é˜²æ­¢æŒ‰éˆ•åœ¨flexå®¹å™¨ä¸­ç¸®å° */
    }
    button:hover:enabled {
        background-color: #e9e9e9;
    }
    button:disabled {
        background-color: #e0e0e0;
        cursor: not-allowed;
        color: #888;
    }
    select {
      padding: 8px 10px; /* å¢åŠ ä¸‹æ‹‰é¸å–®çš„å…§è· */
      font-size: 1.1em;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    /* --- æƒæå™¨èˆ‡åª’é«”éŸ¿æ‡‰å¼ --- */
    #reader {
      width: 100%; /* æƒæå™¨å¯¬åº¦ä½”æ»¿çˆ¶å®¹å™¨ */
      max-width: 350px; /* é™åˆ¶æœ€å¤§å¯¬åº¦ï¼Œé¿å…éå¤§ */
      height: auto; /* é«˜åº¦è‡ªå‹•èª¿æ•´ */
      margin: 20px auto; /* ä¸Šä¸‹é‚Šè·ï¼Œå·¦å³å±…ä¸­ */
      border: 2px solid #333;
      display: block;
      background-color: #000; /* é é˜²å½±ç‰‡åŠ è¼‰å‰æ˜¯ç™½è‰²èƒŒæ™¯ */
    }

    /* --- æƒæè¨˜éŒ„åˆ—è¡¨ --- */
    .record {
      border-bottom: 1px solid #eee; /* è¼•å¾®åº•éƒ¨é‚Šæ¡† */
      padding: 8px 12px; /* èª¿æ•´å…§è·ï¼Œä¸Šä¸‹ç©ºç™½æ›´å° */
      margin-bottom: 5px; /* èª¿æ•´ä¸‹æ–¹é–“è·ï¼Œç©ºç™½æ›´å° */
      background-color: #fcfcfc; /* è¼•å¾®ä¸åŒèƒŒæ™¯ */
      border-radius: 4px; /* åœ“è§’ */
      display: flex;
      flex-direction: column; /* å…§å®¹å’Œé¸é …å‚ç›´å †ç–Š */
      gap: 5px; /* å…§å®¹å¡Šä¹‹é–“çš„é–“è· */
      box-shadow: 0 1px 3px rgba(0,0,0,0.05); /* è¼•å¾®é™°å½± */
    }

    /* æ–°å¢ï¼šæƒæå…§å®¹å’Œæ™‚é–“çš„å®¹å™¨ */
    .content-and-time {
      display: flex;
      align-items: baseline; /* åŸºç·šå°é½Š */
      justify-content: space-between; /* å…§å®¹é å·¦ï¼Œæ™‚é–“é å³ */
      flex-wrap: wrap; /* å…è¨±æ›è¡Œï¼Œä»¥é˜²å…§å®¹éé•· */
      gap: 8px; /* å…§å®¹å’Œæ™‚é–“ä¹‹é–“çš„é–“è· */
    }

    .record strong {
      font-size: 1.15em; /* æƒæå…§å®¹æ›´å¤§ */
      word-break: break-all; /* é˜²æ­¢é•·æ–‡å­—æº¢å‡º */
      flex-grow: 1; /* å…è¨±å…§å®¹ä½”ç”¨æ›´å¤šç©ºé–“ */
      min-width: 0; /* è™•ç†é•·æ–‡å­—åœ¨flexå®¹å™¨ä¸­çš„å•é¡Œ */
    }
    .record .time {
      font-size: 0.85em; /* æ™‚é–“å­—é«”æ›´å° */
      color: #777; /* æ™‚é–“é¡è‰²æ›´æ·¡ */
      white-space: nowrap; /* é˜²æ­¢æ™‚é–“æ›è¡Œ */
      flex-shrink: 0; /* é˜²æ­¢æ™‚é–“ç¸®å° */
    }
    .options {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap; /* æŒ‰éˆ•å¤ªå¤šæ™‚è‡ªå‹•æ›è¡Œ */
      gap: 8px; /* æŒ‰éˆ•ä¹‹é–“çš„é–“è· */
      justify-content: flex-start; /* æŒ‰éˆ•å¾å·¦å´é–‹å§‹æ’åˆ— */
    }
    .options button {
      margin: 0; /* ç§»é™¤é¡å¤–çš„margin */
      padding: 8px 12px; /* èª¿æ•´é¸é …æŒ‰éˆ•å¤§å° */
      font-size: 0.95em;
    }
    .options button[style*="background:#ffa500"],
    .options button[style*="background:#b7f5b7"] {
        border-color: transparent; /* é¸ä¸­ç‹€æ…‹æŒ‰éˆ•ç„¡é‚Šæ¡† */
    }

    /* --- å‚™è¨»æ¡†æ¨£å¼ (é‡å°æ¨¡æ…‹è¦–çª—å…§) --- */
    .remark-section {
        margin-top: 15px; /* èª¿æ•´èˆ‡ä¸Šæ–¹æŒ‰éˆ•çš„é–“è· */
        width: 90%;
        max-width: 500px; /* é…åˆç…§ç‰‡çš„æœ€å¤§å¯¬åº¦ */
        color: white; /* å‚™è¨»å€å¡Šæ–‡å­—é¡è‰²ï¼Œå› ç‚ºèƒŒæ™¯æ˜¯æ·±è‰² */
    }
    .remark-section label {
        font-size: 0.9em;
        color: #ddd; /* æ¨¡æ…‹è¦–çª—èƒŒæ™¯ç‚ºæ·±è‰²ï¼Œæ–‡å­—æ”¹ç‚ºæ·ºè‰² */
        display: block;
        margin-bottom: 3px;
    }
    /* ç‚ºå‚™è¨»æ¡†å’Œæ¸…é™¤æŒ‰éˆ•çš„å®¹å™¨ */
    .remark-input-container {
        display: flex; /* ä½¿ç”¨ Flexbox å¸ƒå±€ */
        align-items: flex-end; /* è®“æŒ‰éˆ•èˆ‡ textarea åº•éƒ¨å°é½Š */
        gap: 5px; /* å‚™è¨»æ¡†èˆ‡æŒ‰éˆ•ä¹‹é–“çš„é–“è· */
    }
    .remark-section textarea {
        flex-grow: 1; /* è®“ textarea ä½”æ“šå¤§éƒ¨åˆ†å¯ç”¨ç©ºé–“ */
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 0.95em;
        resize: none; /* *** é‡è¦ï¼šé˜²æ­¢ç”¨æˆ¶æ‰‹å‹•æ‹‰ä¼¸å°è‡´ JS ç„¡æ³•æ§åˆ¶é«˜åº¦ *** */
        min-height: 35px; /* å°‡æœ€å°é«˜åº¦è¨­å®šå¾—æ›´å°ï¼Œä¾‹å¦‚ 35px */
        max-height: none !important; /* *** æœ€é‡è¦ï¼šç¢ºä¿æ²’æœ‰æœ€å¤§é«˜åº¦é™åˆ¶ï¼Œä½¿ç”¨ !important æé«˜å„ªå…ˆç´š *** */
        box-sizing: border-box; /* ç¢ºä¿ padding ä¸å½±éŸ¿å¯¬åº¦è¨ˆç®— */
        background-color: #333; /* é…åˆæ¨¡æ…‹è¦–çª—çš„æ·±è‰²èƒŒæ™¯ */
        color: white;
        overflow-y: hidden !important; /* *** æœ€é‡è¦ï¼šç¢ºä¿éš±è—æ»¾å‹•æ¢ï¼Œä½¿ç”¨ !important æé«˜å„ªå…ˆç´š *** */
        min-width: 0; /* ç¢ºä¿åœ¨ Flex å®¹å™¨ä¸­å¯ä»¥æ­£ç¢ºç¸®å°å’Œæ“´å±• */
        height: auto; /* åˆå§‹å€¼ç‚º autoï¼Œè®“ JS é€²è¡Œè¨ˆç®— */
        line-height: 1.2; /* è®“è¡Œé«˜æ›´ç·Šæ¹Šä¸€äº›ï¼Œæœ‰åŠ©æ–¼è¨ˆç®— */
    }
    /* æ¸…é™¤å‚™è¨»æŒ‰éˆ•çš„æ¨£å¼ */
    #clearRemarkBtn {
        padding: 8px 10px; /* èª¿æ•´æŒ‰éˆ•å¤§å° */
        font-size: 0.85em;
        background-color: #ff5722; /* æ©™ç´…è‰² */
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        align-self: flex-end; /* *** è®“æŒ‰éˆ•åº•éƒ¨å°é½Šï¼Œä¸å†æ‹‰ä¼¸ *** */
        height: 35px; /* *** æ˜ç¢ºè¨­å®šæŒ‰éˆ•å›ºå®šé«˜åº¦ï¼Œèˆ‡ min-height ä¿æŒä¸€è‡´ *** */
        margin: 0; /* ç§»é™¤é è¨­ margin */
    }
    #clearRemarkBtn:hover {
        background-color: #e64a19;
    }

    /* å­—æ•¸çµ±è¨ˆ */
    #remarkCharCount {
        font-size: 0.8em;
        color: #aaa;
        text-align: right; /* è®“å­—æ•¸çµ±è¨ˆé å³ */
        width: 100%; /* ä½”æ“šæ•´å€‹å¯¬åº¦ */
        margin-top: 2px; /* èˆ‡å‚™è¨»æ¡†çš„é–“è· */
    }

    /* --- ç¯©é¸å™¨èˆ‡çµ±è¨ˆè³‡è¨Šå€å¡Š --- */
    .filter-stats-container {
        display: flex;
        flex-wrap: wrap; /* å…è¨±æ›è¡Œ */
        align-items: center; /* å‚ç›´å±…ä¸­å°é½Š */
        gap: 10px; /* å…ƒç´ é–“è· */
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #eee;
    }
    .filter-stats-container label {
        font-weight: bold;
        color: #555;
        font-size: 1.1em; /* èˆ‡é¸æ“‡æ¡†å­—é«”å¤§å°ç›¸åŒ */
    }
    #statusStats {
        font-size: 1.1em; /* èª¿æ•´å­—é«”å¤§å°èˆ‡ç¯©é¸å™¨ç›¸åŒ */
        color: #444;
        margin-left: 0; /* ç§»é™¤èˆŠçš„å·¦é‚Šè· */
        white-space: nowrap; /* é˜²æ­¢çµ±è¨ˆæ•¸å­—æ›è¡Œ */
    }

    /* --- æ¡Œé¢ç‰ˆåª’é«”æŸ¥è©¢ (Desktop Media Query) --- */
    @media (min-width: 600px) {
      .filter-stats-container {
        flex-wrap: nowrap; /* æ¡Œé¢ç‰ˆä¸æ›è¡Œ */
        border-bottom: 3px double #ccc; /* æ¡Œé¢ç‰ˆåº•éƒ¨é›™ç·š */
      }
      .filter-stats-container label {
        margin-right: 10px; /* æ¨™ç±¤èˆ‡é¸å–®çš„é–“è· */
      }
      #statusStats {
        margin-left: auto; /* æ¨åˆ°å³é‚Š */
        margin-top: 0; /* ç§»é™¤å‚ç›´é–“è· */
        border-bottom: none; /* ç§»é™¤å€‹åˆ¥çµ±è¨ˆçš„åº•éƒ¨é‚Šæ¡† */
      }
      .options button {
          padding: 6px 12px; /* æ¡Œé¢ç‰ˆæŒ‰éˆ•æ¢å¾©åŸå§‹å¤§å° */
          font-size: 1em;
      }
    }

    /* --- æ¨¡æ…‹è¦–çª—æ¨£å¼ --- */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      padding: 10px; /* å¢åŠ æ¨¡æ…‹è¦–çª—å…§é‚Šè· */
      box-sizing: border-box; /* ç¢ºä¿paddingä¸å½±éŸ¿å¯¬é«˜è¨ˆç®— */
      overflow-y: auto; /* å…è¨±åœ¨å…§å®¹éé•·æ™‚æ»¾å‹• */
    }
    .modal-video-preview {
      width: 90%; /* è®“å½±ç‰‡é è¦½åœ¨æ‰‹æ©Ÿä¸Šä½”æ›´å¯¬ */
      max-width: 500px; /* é™åˆ¶æœ€å¤§å¯¬åº¦ */
      height: auto; /* è‡ªå‹•èª¿æ•´é«˜åº¦ */
      max-height: 70vh; /* é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œä¿ç•™ä¸‹æ–¹æ§åˆ¶æŒ‰éˆ•ç©ºé–“ */
      object-fit: cover;
      background-color: #000;
      border: 2px solid white; /* é‚Šæ¡† */
    }
    .modal-controls {
        margin-top: 20px;
        display: flex;
        gap: 15px; /* æŒ‰éˆ•é–“è· */
        flex-wrap: wrap; /* è®“æŒ‰éˆ•å¯ä»¥æ›è¡Œ */
        justify-content: center; /* æŒ‰éˆ•å±…ä¸­ */
    }
    .modal-controls button {
      padding: 12px 25px; /* æ¨¡æ…‹è¦–çª—æŒ‰éˆ•æ›´å¤§ */
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1.1em;
    }
    /* Updated button colors for better contrast */
    .btn-cancel {
        background: #f44336; /* Red background */
        color: white; /* White text for better contrast */
    }
    .btn-capture {
        background: #4CAF50; /* Green background */
        color: white; /* White text for better contrast */
    }
    .btn-save { /* å·²ä¸å†ç”¨æ–¼å„²å­˜å¡—é´‰ï¼Œä½†å¯èƒ½ç”¨æ–¼å…¶ä»–å„²å­˜æŒ‰éˆ• */
        background: #007bff; /* Blue background */
        color: white; /* White text for better contrast */
    }


    /* Photo Display Modal (for doodling) */
    #photoDisplayModal {
        /* display: none; will be set by JS */
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 10px;
    }
    #doodleCanvas {
        max-width: 95%; /* ç•«å¸ƒæœ€å¤§å¯¬åº¦ */
        max-height: 60vh; /* ç•«å¸ƒæœ€å¤§é«˜åº¦ï¼Œç‚ºæ§åˆ¶é …å’Œå‚™è¨»ç•™ç©ºé–“ */
        border: 2px solid white;
        background-color: #000; /* ç¢ºä¿èƒŒæ™¯ç‚ºé»‘è‰²ï¼Œé¿å…é€æ˜æ™‚çœ‹åˆ°å¾Œé¢ */
        touch-action: none; /* é˜²æ­¢è§¸æ§è¢å¹•æ»¾å‹• */
    }
    .doodle-controls {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap; /* å…è¨±æ›è¡Œ */
        gap: 8px; /* èª¿æ•´æŒ‰éˆ•é–“è·ï¼Œä½¿å…¶åœ¨æ‰‹æ©Ÿä¸Šæ›´ç·Šæ¹Š */
        justify-content: center;
        align-items: center;
    }
    .doodle-controls input[type="color"] {
        width: 40px;
        height: 40px;
        border: none;
        padding: 0;
        cursor: pointer;
    }
    .doodle-controls button {
        padding: 8px 12px; /* ç¨å¾®èª¿æ•´æŒ‰éˆ•å…§è·ï¼Œä½¿å…¶åœ¨æ‰‹æ©Ÿä¸Šæ›´ç·Šæ¹Š */
        font-size: 0.95em; /* ç¨å¾®èª¿æ•´å­—é«”å¤§å° */
    }


    /* Hidden Canvas for photo capture */
    #photoCanvas { display: none; }

    /* New style for the scanner header */
    .scanner-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>ğŸ“‹ å±¤æ¶ç‹€æ…‹è¨˜éŒ„</h1>
  <button id="soundBtn">ğŸ”‡ éŸ³æ•ˆé—œé–‰</button>
  <button id="exportBtn">ğŸ“¤ åŒ¯å‡ºè³‡æ–™</button>

  <video id="reader"></video>

  <div class="scanner-header">
    <h2>ğŸ“· æƒæè¨˜éŒ„</h2>
    <button id="toggleScannerBtn">é—œé–‰é¡é ­</button>
  </div>

  <div class="filter-stats-container">
    <label for="statusFilter">ç¯©é¸ç‹€æ…‹:</label>
    <select id="statusFilter">
      <option value="">å…¨éƒ¨ç‹€æ…‹</option>
      <option value="restock">è£œè²¨</option>
      <option value="empty">ç©ºä½</option>
    </select>
    <div id="statusStats"></div>
  </div>

  <div id="resultList"></div>

  <div id="photoCaptureModal" class="modal">
    <video id="photoCapturePreview" class="modal-video-preview" autoplay playsinline></video>
    <canvas id="photoCanvas"></canvas>
    <div class="modal-controls">
        <button id="captureBtn" class="btn-capture" disabled>æ‹ç…§</button>
        <button id="photoCaptureCancel" class="btn-cancel">å–æ¶ˆ</button>
    </div>
  </div>

  
<div id="photoDisplayModal" class="modal">
      <canvas id="doodleCanvas"></canvas>
      <div class="doodle-controls">
          <input type="color" id="doodleColor" value="#FF0000">
          <button id="clearDoodleBtn">æ¸…é™¤å¡—é´‰</button>
          <button id="closeDoodleBtn" class="btn-cancel">é—œé–‰</button>
      </div>
      <div class="remark-section">
          <label for="modalRemarkTextarea">å‚™è¨»:</label>
          <div class="remark-input-container">
              <textarea id="modalRemarkTextarea"></textarea>
              <button id="clearRemarkBtn">æ¸…é™¤</button>
          </div>
          <span id="remarkCharCount"></span>
      </div>
  </div>

  <script>
    const STORAGE_KEY = "shelf-scan-history";
    const SOUND_KEY = "sound-enabled";
    const REMARK_MAX_LENGTH = 120; // å‚™è¨»å­—æ•¸ä¸Šé™
    const REMARK_MIN_HEIGHT = '35px'; // å®šç¾©å‚™è¨»æ¡†çš„æœ€å°é«˜åº¦ï¼Œèˆ‡ CSS ä¿æŒä¸€è‡´

    // DOM Elements
    const resultList = document.getElementById("resultList");
    const statusFilter = document.getElementById("statusFilter");
    const statusStats = document.getElementById("statusStats");
    const exportBtn = document.getElementById("exportBtn");
    const soundBtn = document.getElementById("soundBtn");
    const toggleScannerBtn = document.getElementById("toggleScannerBtn"); // New button

    // Photo Capture Modal Elements
    const photoCaptureModal = document.getElementById("photoCaptureModal");
    const photoCapturePreview = document.getElementById("photoCapturePreview");
    const photoCanvas = document.getElementById("photoCanvas");
    const captureBtn = document.getElementById("captureBtn");
    const photoCaptureCancel = document.getElementById("photoCaptureCancel");

    // Photo Display Modal Elements (for doodling and remark)
    const photoDisplayModal = document.getElementById("photoDisplayModal");
    const doodleCanvas = document.getElementById("doodleCanvas");
    const doodleCtx = doodleCanvas.getContext('2d');
    const doodleColorInput = document.getElementById("doodleColor");
    const clearDoodleBtn = document.getElementById("clearDoodleBtn");
    // const saveDoodleBtn = document.getElementById("saveDoodleBtn"); // å„²å­˜å¡—é´‰æŒ‰éˆ•å·²ç§»é™¤
    const closeDoodleBtn = document.getElementById("closeDoodleBtn"); 
    const modalRemarkTextarea = document.getElementById("modalRemarkTextarea"); // æ¨¡æ…‹è¦–çª—å‚™è¨»æ¡†
    const clearRemarkBtn = document.getElementById("clearRemarkBtn"); // æ–°å¢ï¼šæ¸…é™¤å‚™è¨»æŒ‰éˆ•
    const remarkCharCount = document.getElementById("remarkCharCount"); // æ–°å¢ï¼šå­—æ•¸çµ±è¨ˆå…ƒç´ 

    let currentScanner = null;
    let currentPhotoTargetTime = null; // Renamed for clarity: stores the time of the record being edited
    let soundEnabled = false;
    let lastScanTimeMap = {};
    let photoStream = null;
    let scannerActive = true;

    // Doodling variables
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let originalPhotoDataUrl = null; // To store the original photo before doodling

    document.addEventListener('DOMContentLoaded', function() {
      initSound();
      loadHistory();
      startMainScanner();
      statusFilter.addEventListener('change', loadHistory);
      exportBtn.addEventListener('click', exportCSV);
      soundBtn.addEventListener('click', toggleSound);

      // Event Listeners for modals
      captureBtn.addEventListener('click', capturePhoto);
      photoCaptureCancel.addEventListener('click', cancelPhotoCapture);
      toggleScannerBtn.addEventListener('click', toggleScanner);

      // Event Listeners for doodling
      doodleCanvas.addEventListener('mousedown', startDrawing);
      doodleCanvas.addEventListener('mousemove', draw);
      doodleCanvas.addEventListener('mouseup', stopDrawing);
      doodleCanvas.addEventListener('mouseout', stopDrawing); // Stop drawing if mouse leaves canvas

      doodleCanvas.addEventListener('touchstart', startDrawing);
      doodleCanvas.addEventListener('touchmove', draw);
      doodleCanvas.addEventListener('touchend', stopDrawing);
      doodleCanvas.addEventListener('touchcancel', stopDrawing);

      // === START MODIFICATION FOR clearDoodleBtn ===
      clearDoodleBtn.addEventListener('click', clearDoodle); 
      
      clearDoodleBtn.addEventListener('touchstart', function(event) {
          event.preventDefault(); 
      });

      clearDoodleBtn.addEventListener('touchend', function(event) {
          event.preventDefault(); 
          clearDoodle(); 
      });
      // === END MODIFICATION FOR clearDoodleBtn ===

      // const saveDoodleBtn = document.getElementById("saveDoodleBtn"); // å„²å­˜å¡—é´‰æŒ‰éˆ•çš„äº‹ä»¶ç›£è½å™¨å·²ç§»é™¤

      // ä»¥ä¸‹æ˜¯é‡å° closeDoodleBtn çš„æ‰€æœ‰ä¿®æ”¹ï¼š
      closeDoodleBtn.addEventListener('click', closePhotoDisplay); 
      
      closeDoodleBtn.addEventListener('touchstart', function(event) {
          event.preventDefault(); 
      });

      closeDoodleBtn.addEventListener('touchend', function(event) {
          event.preventDefault(); 
          modalRemarkTextarea.blur(); 
          closePhotoDisplay(); 
      });

      // å‚™è¨»æ¡†è¼¸å…¥æ™‚è‡ªå‹•èª¿æ•´é«˜åº¦ã€å³æ™‚æˆªæ–·å’Œå­—æ•¸çµ±è¨ˆ
      modalRemarkTextarea.addEventListener('input', () => {
        // å³æ™‚æˆªæ–·æ–‡å­—
        if (modalRemarkTextarea.value.length > REMARK_MAX_LENGTH) {
            modalRemarkTextarea.value = modalRemarkTextarea.value.substring(0, REMARK_MAX_LENGTH);
        }
        autoResizeRemarkTextarea(); // èª¿æ•´é«˜åº¦
        updateRemarkCharCount(); // æ›´æ–°å­—æ•¸çµ±è¨ˆ
      });
      // æ–°å¢ï¼šåœ¨å‚™è¨»æ¡†å¤±å»ç„¦é»æ™‚ï¼Œä¹Ÿèª¿æ•´é«˜åº¦ï¼Œä»¥é˜²å…§å®¹åœ¨è¤‡è£½è²¼ä¸Šç­‰æ“ä½œå¾Œæœªè‡ªå‹•èª¿æ•´
      modalRemarkTextarea.addEventListener('blur', autoResizeRemarkTextarea);
      // æ–°å¢ï¼šæ¸…é™¤å‚™è¨»æŒ‰éˆ•çš„äº‹ä»¶ç›£è½å™¨
      clearRemarkBtn.addEventListener('click', clearRemark);

      // --- æ–°å¢ï¼šå‹•æ…‹è¨­å®šå‚™è¨»æ¡†çš„ placeholder å’Œ maxlength ---
      modalRemarkTextarea.placeholder = `è¼¸å…¥å‚™è¨» (æœ€å¤š ${REMARK_MAX_LENGTH} å­—)`;
      modalRemarkTextarea.setAttribute('maxlength', REMARK_MAX_LENGTH); // å‹•æ…‹è¨­å®š maxlength
      updateRemarkCharCount(); // åˆå§‹åŒ–æ™‚ä¹Ÿæ›´æ–°ä¸€æ¬¡å­—æ•¸çµ±è¨ˆ
    });

    // Stop all media streams
    function stopAllStreams() {
        if (photoStream) {
            photoStream.getTracks().forEach(track => track.stop());
            photoStream = null;
        }
        if (currentScanner) {
            currentScanner.reset();
            currentScanner = null;
        }
    }

    async function startMainScanner() {
        stopAllStreams();
        try {
            const hints = new Map();
            // è¨­å®šåªè¾¨è­˜ QR Code
            hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [ZXing.BarcodeFormat.QR_CODE]);

            currentScanner = new ZXing.BrowserMultiFormatReader(hints); // å‚³å…¥ hints åƒæ•¸
            await currentScanner.decodeFromVideoDevice(
                undefined,
                'reader',
                (result, err) => {
                    if (result) {
                        const now = Date.now();
                        const lastTime = lastScanTimeMap[result.text] || 0;
                        if (now - lastTime >= 5000) {
                            lastScanTimeMap[result.text] = now;
                            addHistory(result.text);
                        } else {
                            console.log("ä¸»æƒæï¼š5ç§’å…§é‡è¤‡æƒæï¼Œå·²ç•¥é", result.text);
                        }
                    }
                    if (err && !(err instanceof ZXing.NotFoundException)) {
                        console.error(err);
                    }
                }
            );
            scannerActive = true;
            toggleScannerBtn.textContent = "é—œé–‰é¡é ­";
        } catch (err) {
            console.error("æƒæå™¨åˆå§‹åŒ–å¤±æ•—:", err);
            scannerActive = false;
            toggleScannerBtn.textContent = "é–‹å•Ÿé¡é ­";
        }
    }

    function stopMainScanner() {
      stopAllStreams();
      if (currentScanner) {
        currentScanner.reset();
        currentScanner = null;
      }
      scannerActive = false;
      toggleScannerBtn.textContent = "é–‹å•Ÿé¡é ­";
    }

    function toggleScanner() {
      if (scannerActive) {
        stopMainScanner();
      } else {
        startMainScanner();
      }
    }

    function addHistory(data) {
        const list = getHistoryList();
        const existingRecord = list.find(item => item.data === data);
        const now = new Date().toISOString();
        let recordToScrollId = '';

        if (existingRecord) {
            existingRecord.time = now;
            existingRecord.status = "restock"; // <--- é‡æ–°æƒææ™‚ï¼Œé è¨­ç‚ºã€Œè£œè²¨ã€
            // å‚™è¨»ä¸è®Šï¼Œé™¤éç”¨æˆ¶æ‰‹å‹•ç·¨è¼¯
            recordToScrollId = `record-${existingRecord.time}`;
        } else {
            const newRecord = {
                data: data,
                time: now,
                status: "restock", // <--- æ–°å¢è¨˜éŒ„æ™‚ï¼Œé è¨­ç‚ºã€Œè£œè²¨ã€
                photo: null,
                originalPhoto: null, // æ–°å¢ originalPhoto æ¬„ä½
                remark: "" // æ–°å¢ï¼šå‚™è¨»æ¬„ä½ï¼Œé è¨­ç‚ºç©ºå­—ä¸²
            };
            list.unshift(newRecord);
            recordToScrollId = `record-${newRecord.time}`;
        }
        saveHistoryList(list);
        loadHistory();
        playBeep();

        setTimeout(() => {
            const element = document.getElementById(recordToScrollId);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }, 100);
    }

    async function startPhotoCapture(time) {
        currentPhotoTargetTime = time; // Store the time of the record
        stopAllStreams();
        photoCaptureModal.style.display = 'flex';
        try {
            photoStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            photoCapturePreview.srcObject = photoStream;

            photoCapturePreview.onloadedmetadata = () => {
                photoCapturePreview.play().catch(err => console.error("å½±ç‰‡æ’­æ”¾å¤±æ•—:", err));
                captureBtn.disabled = false;
            };

        } catch (err) {
            console.error("ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿ:", err);
            alert("ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿï¼Œè«‹æª¢æŸ¥æ¬Šé™æˆ–è£ç½®ã€‚\néŒ¯èª¤è¨Šæ¯: " + err.message);
            cancelPhotoCapture();
        }
    }

    function capturePhoto() {
        const context = photoCanvas.getContext('2d');
        photoCanvas.width = photoCapturePreview.videoWidth;
        photoCanvas.height = photoCapturePreview.videoHeight;
        context.drawImage(photoCapturePreview, 0, 0, photoCanvas.width, photoCanvas.height);

        const dataUrl = photoCanvas.toDataURL('image/jpeg', 0.8);
        const list = getHistoryList();
        const record = list.find(item => item.time === currentPhotoTargetTime);

        if (record) {
            record.photo = dataUrl;
            record.originalPhoto = dataUrl; // æ–°å¢ï¼šç¬¬ä¸€æ¬¡æ‹ç…§æ™‚ï¼ŒåŒæ™‚å„²å­˜ç‚ºåŸå§‹ç…§ç‰‡
            saveHistoryList(list);
            playBeep();
        }

        photoCaptureModal.style.display = 'none';
        stopAllStreams();
        startMainScanner();
        showPhoto(currentPhotoTargetTime); // Show the photo immediately after capture
    }

    function cancelPhotoCapture() {
        photoCaptureModal.style.display = 'none';
        currentPhotoTargetTime = null;
        captureBtn.disabled = true;
        if (photoStream) {
            photoStream.getTracks().forEach(track => track.stop());
            photoStream = null;
        }
        photoCapturePreview.srcObject = null;
        startMainScanner();
        loadHistory();
        setTimeout(() => {
            if (resultList.firstElementChild) {
                resultList.firstElementChild.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }, 100);
    }

    // --- Doodling Functions ---
    function showPhoto(time) {
        console.log("showPhoto called for time:", time);
        const list = getHistoryList();
        const record = list.find(item => item.time === time);
        if (record && record.photo) {
            // å¦‚æœ originalPhoto ä¸å­˜åœ¨ (é‡å°èˆŠè¨˜éŒ„)ï¼Œå‰‡å°‡ current photo è¨­ç‚ºåŸå§‹ç…§ç‰‡ä¸¦å„²å­˜
            if (!record.originalPhoto) {
                record.originalPhoto = record.photo;
                saveHistoryList(list); // æŒä¹…åŒ–æ­¤æ”¹è®Š
            }
            // å¦‚æœ remark ä¸å­˜åœ¨ (é‡å°èˆŠè¨˜éŒ„)ï¼Œå‰‡å°‡å…¶åˆå§‹åŒ–ç‚ºç©ºå­—ä¸²
            if (record.remark === undefined) {
                record.remark = "";
                saveHistoryList(list); // æŒä¹…åŒ–æ­¤æ”¹è®Š
            }

            originalPhotoDataUrl = record.originalPhoto; // æ¸…é™¤å¡—é´‰æ™‚ä½¿ç”¨çš„åŸå§‹ç…§ç‰‡

            const img = new Image();
            img.onload = () => {
                // èª¿æ•´ç•«å¸ƒå¤§å°ä»¥é©æ‡‰åœ–ç‰‡ä¸¦ä¿æŒé•·å¯¬æ¯”
                const maxWidth = window.innerWidth * 0.95;
                const maxHeight = window.innerHeight * 0.60; // ç‚ºæ§åˆ¶é …å’Œå‚™è¨»ä¿ç•™æ›´å¤šç©ºé–“

                let width = img.width;
                let height = img.height;

                if (width > maxWidth) {
                    height = height * (maxWidth / width);
                    width = maxWidth;
                }
                if (height > maxHeight) {
                    width = width * (maxHeight / height);
                    height = maxHeight;
                }

                doodleCanvas.width = width;
                doodleCanvas.height = height;

                doodleCtx.clearRect(0, 0, doodleCanvas.width, doodleCanvas.height); // æ¸…é™¤ä¹‹å‰çš„ç¹ªåœ–
                doodleCtx.drawImage(img, 0, 0, doodleCanvas.width, doodleCanvas.height); // ç¹ªè£½ç•¶å‰ (å¯èƒ½å·²å¡—é´‰é) çš„åœ–ç‰‡
            };
            img.src = record.photo; // å§‹çµ‚è¼‰å…¥ç•¶å‰ (å¯èƒ½å·²å¡—é´‰é) çš„ç…§ç‰‡ä»¥ä¾›åˆå§‹é¡¯ç¤º
            
            // å¡«å……æ¨¡æ…‹è¦–çª—å…§çš„å‚™è¨»æ¡†ï¼Œä¸¦ç¢ºä¿ä¸è¶…å‡º REMARK_MAX_LENGTH
            modalRemarkTextarea.value = record.remark.substring(0, REMARK_MAX_LENGTH);
            // è¼‰å…¥å‚™è¨»å¾Œç«‹å³èª¿æ•´å‚™è¨»æ¡†é«˜åº¦
            autoResizeRemarkTextarea();
            updateRemarkCharCount(); // è¼‰å…¥æ™‚æ›´æ–°å­—æ•¸çµ±è¨ˆ

            photoDisplayModal.style.display = 'flex';
            currentPhotoTargetTime = time; // è¨­å®šå„²å­˜å¡—é´‰å’Œå‚™è¨»çš„ç›®æ¨™æ™‚é–“
        } else {
            alert("æ‰¾ä¸åˆ°ç…§ç‰‡!");
        }
    }

    function getMousePos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (evt.clientX - rect.left) * scaleX,
            y: (evt.clientY - rect.top) * scaleY
        };
    }

    function getTouchPos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const touch = evt.touches[0];
        return {
            x: (touch.clientX - rect.left) * scaleX,
            y: (touch.clientY - rect.top) * scaleY
        };
    }

    function startDrawing(e) {
        e.preventDefault(); // é˜²æ­¢è§¸æ§è¢å¹•æ»¾å‹•
        isDrawing = true;
        const pos = e.type.includes('mouse') ? getMousePos(doodleCanvas, e) : getTouchPos(doodleCanvas, e);
        [lastX, lastY] = [pos.x, pos.y];
        doodleCtx.beginPath();
        doodleCtx.moveTo(lastX, lastY);
    }

    function draw(e) {
        if (!isDrawing) return;
        e.preventDefault(); // é˜²æ­¢è§¸æ§è¢å¹•æ»¾å‹•
        const pos = e.type.includes('mouse') ? getMousePos(doodleCanvas, e) : getTouchPos(doodleCanvas, e);

        doodleCtx.lineWidth = 5; // èª¿æ•´ç·šæ¢å¯¬åº¦
        doodleCtx.lineCap = 'round';
        doodleCtx.strokeStyle = doodleColorInput.value;

        doodleCtx.lineTo(pos.x, pos.y);
        doodleCtx.stroke();
        [lastX, lastY] = [pos.x, pos.y];
    }

    function stopDrawing() {
        isDrawing = false;
        doodleCtx.closePath();
    }

    function clearDoodle() {
        if (originalPhotoDataUrl) {
            const img = new Image();
            img.onload = () => {
                doodleCtx.clearRect(0, 0, doodleCanvas.width, doodleCanvas.height);
                doodleCtx.drawImage(img, 0, 0, doodleCanvas.width, doodleCanvas.height);
            };
            img.src = originalPhotoDataUrl; // ä½¿ç”¨å„²å­˜çš„åŸå§‹ç…§ç‰‡ä¾†æ¸…é™¤
        } else {
            doodleCtx.clearRect(0, 0, doodleCanvas.width, doodleCanvas.height);
        }
    }

    // å°‡ saveDoodle é‚è¼¯ç§»å…¥ closePhotoDisplay
    // function saveDoodle() { ... } // é€™å€‹å‡½å¼å·²ç¶“ä¸å†éœ€è¦ç¨ç«‹å­˜åœ¨

    function closePhotoDisplay() {
        console.log("Closing photo display and calling loadHistory()");
        
        // *** å¼·åˆ¶å‚™è¨»è¼¸å…¥æ¡†å¤±å»ç„¦é»ï¼Œä»¥è§£æ±ºæ‰‹æ©Ÿè»Ÿéµç›¤å•é¡Œ ***
        modalRemarkTextarea.blur(); 

        // ç¢ºä¿æœ‰ä¸Šä¸‹æ–‡è¨˜éŒ„ï¼Œæ‰åŸ·è¡Œå„²å­˜
        if (currentPhotoTargetTime) { 
            // 1. å„²å­˜å¡—é´‰
            const dataUrl = doodleCanvas.toDataURL('image/jpeg', 0.8);
            const list = getHistoryList();
            const record = list.find(item => item.time === currentPhotoTargetTime);

            if (record) {
                record.photo = dataUrl; // æ›´æ–°å¡—é´‰å¾Œçš„ç…§ç‰‡
                // originalPhoto ä¿æŒä¸è®Šï¼Œå› ç‚ºå®ƒæ˜¯åŸå§‹ç…§ç‰‡
                saveHistoryList(list);
                console.log("å¡—é´‰å·²è‡ªå‹•å„²å­˜ï¼");
            } else {
                console.error("Error: Record not found for saving doodle on close. Time:", currentPhotoTargetTime);
            }

            // 2. å„²å­˜å‚™è¨»
            saveRemark(currentPhotoTargetTime, modalRemarkTextarea.value);
        }

        photoDisplayModal.style.display = 'none';
        doodleCtx.clearRect(0, 0, doodleCanvas.width, doodleCanvas.height); // æ¸…é™¤ç•«å¸ƒ
        originalPhotoDataUrl = null; // æ¸…é™¤åŸå§‹ç…§ç‰‡åƒè€ƒ
        currentPhotoTargetTime = null; // æ¸…é™¤ç›®æ¨™æ™‚é–“
        modalRemarkTextarea.value = ''; // æ¸…ç©ºæ¨¡æ…‹è¦–çª—å‚™è¨»æ¡†
        // ç¢ºä¿é—œé–‰æ™‚å‚™è¨»æ¡†é‡ç½®ç‚ºæœ€å°é«˜åº¦
        modalRemarkTextarea.style.height = REMARK_MIN_HEIGHT;
        updateRemarkCharCount(); // æ¸…ç©ºå¾Œæ›´æ–°å­—æ•¸çµ±è¨ˆ

        loadHistory();
        setTimeout(() => {
            if (resultList.firstElementChild) {
                resultList.firstElementChild.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }, 100);
    }
    // --- End Doodling Functions ---


    // å„²å­˜å‚™è¨»çš„å‡½å¼
    function saveRemark(time, newRemarkValue) {
        const list = getHistoryList();
        const record = list.find(item => item.time === time);
        if (record) {
            // ç¢ºä¿å‚™è¨»ä¸æœƒè¶…éæœ€å¤§é•·åº¦
            record.remark = newRemarkValue.substring(0, REMARK_MAX_LENGTH);
            saveHistoryList(list);
            console.log(`å‚™è¨»å·²å„²å­˜ï¼šè¨˜éŒ„æ™‚é–“ ${time}, å‚™è¨»å…§å®¹ "${record.remark}"`);
        }
    }

    // æ–°å¢ï¼šè‡ªå‹•èª¿æ•´å‚™è¨»æ¡†é«˜åº¦çš„å‡½å¼
    function autoResizeRemarkTextarea() {
        // å…ˆå°‡é«˜åº¦è¨­ç‚º 'auto' ä»¥ä¾¿ç€è¦½å™¨é‡æ–°è¨ˆç®—å…§å®¹é«˜åº¦
        modalRemarkTextarea.style.height = 'auto'; 
        // ç¢ºä¿ overflow-y ç‚º hidden
        modalRemarkTextarea.style.overflowY = 'hidden';

        // ä½¿ç”¨ requestAnimationFrame ç¢ºä¿åœ¨ä¸‹ä¸€æ¬¡ç¹ªè£½å‰ï¼Œç€è¦½å™¨æœ‰æ©Ÿæœƒè¨ˆç®—æ­£ç¢ºçš„ scrollHeight
        window.requestAnimationFrame(() => {
            let newHeight = modalRemarkTextarea.scrollHeight;
            
            // å¦‚æœè¨ˆç®—å‡ºä¾†çš„é«˜åº¦å°æ–¼æœ€å°é«˜åº¦ï¼Œå‰‡ä½¿ç”¨æœ€å°é«˜åº¦
            if (newHeight < parseFloat(REMARK_MIN_HEIGHT)) {
                newHeight = parseFloat(REMARK_MIN_HEIGHT);
            }

            modalRemarkTextarea.style.height = newHeight + 'px';

            // è§€å¯Ÿ `scrollHeight` çš„å€¼ï¼Œç”¨æ–¼é™¤éŒ¯
            console.log("å‚™è¨»æ¡†å€¼:", modalRemarkTextarea.value);
            console.log("è¨ˆç®—å¾Œ scrollHeight:", modalRemarkTextarea.scrollHeight);
            console.log("è¨­å®šé«˜åº¦ç‚º:", modalRemarkTextarea.style.height);
            console.log("è¨ˆç®—å¾Œ clientHeight:", modalRemarkTextarea.clientHeight);

            // æœ€çµ‚æª¢æŸ¥ï¼šå¦‚æœ scrollHeight ä»ç„¶å¤§æ–¼ clientHeightï¼Œè¡¨ç¤ºä»æœ‰éš±è—å…§å®¹
            // é€™ä¸æ‡‰è©²ç™¼ç”Ÿå¦‚æœ autoResizeRemarkTextarea æ­£å¸¸å·¥ä½œ
            if (modalRemarkTextarea.scrollHeight > modalRemarkTextarea.clientHeight) {
                console.warn("è­¦å‘Šï¼šå‚™è¨»æ¡†å…§å®¹ä»æº¢å‡ºï¼ŒscrollHeight å¤§æ–¼ clientHeightï¼");
            }
        });
    }

    // æ–°å¢ï¼šæ›´æ–°å‚™è¨»æ¡†å­—æ•¸çµ±è¨ˆ
    function updateRemarkCharCount() {
        const currentLength = modalRemarkTextarea.value.length;
        remarkCharCount.textContent = `${currentLength}/${REMARK_MAX_LENGTH} å­—`;
        // å¯ä»¥æ ¹æ“šæ˜¯å¦è¶…å‡ºè‡ªå®šç¾©é¡è‰²
        remarkCharCount.style.color = currentLength > REMARK_MAX_LENGTH ? '#ff5722' : '#aaa';
    }


    // æ–°å¢ï¼šæ¸…é™¤å‚™è¨»æ¡†å…§å®¹çš„å‡½å¼
    function clearRemark() {
        modalRemarkTextarea.value = '';
        autoResizeRemarkTextarea(); // æ¸…ç©ºå¾Œèª¿æ•´å›æœ€å°é«˜åº¦
        updateRemarkCharCount(); // æ¸…ç©ºå¾Œæ›´æ–°å­—æ•¸çµ±è¨ˆ
        // å¦‚æœç•¶å‰æœ‰è¨˜éŒ„æ­£åœ¨ç·¨è¼¯ï¼Œä¸¦ä¸”éœ€è¦ç«‹å³å„²å­˜æ¸…ç©ºçš„å‚™è¨»
        if (currentPhotoTargetTime) {
            saveRemark(currentPhotoTargetTime, ''); // å„²å­˜ç©ºå‚™è¨»
        }
    }


    function handleStatusChange(time, status) {
        console.log("handleStatusChange called. Time:", time, "Status:", status);
        const list = getHistoryList();
        const recordIndex = list.findIndex(item => item.time === time);
        if (recordIndex !== -1) {
            console.log("Record found for delete/status change:", list[recordIndex].data);
            if (status === "delete") {
                if (confirm(`ç¢ºå®šåˆªé™¤è¨˜éŒ„: ${list[recordIndex].data}ï¼Ÿ`)) {
                    list.splice(recordIndex, 1);
                    console.log("Record deleted. New list length:", list.length);
                }
            } else {
                list[recordIndex].status = status;
                console.log("Record status updated to:", status);
            }
            saveHistoryList(list);
            loadHistory();
        } else {
            console.warn("Record not found for handleStatusChange. Time:", time);
        }
    }

    function loadHistory() {
        console.log("loadHistory() called.");
        const list = getHistoryList();
        const filter = statusFilter.value;
        const filtered = filter ? list.filter(item => item.status === filter) : list;

        const stats = {
            restock: list.filter(item => item.status === "restock").length,
            empty: list.filter(item => item.status === "empty").length,
        };

        statusStats.innerHTML = `
            è£œè²¨: ${stats.restock} |
            ç©ºä½: ${stats.empty}
        `;

        resultList.innerHTML = filtered.map(item => {
            return `
            <div class="record" id="record-${item.time}" data-time="${item.time}" data-status="${item.status}">
                <div class="content-and-time">
                    <strong>${item.data}</strong>
                    <div class="time">${formatTime(item.time)}</div>
                </div>
                <div class="options">
                    <button onclick="handleStatusChange('${item.time}', 'restock')"
                        ${item.status === 'restock' ? 'style="background:#ffa500;color:white"' : ''}>
                        è£œè²¨
                    </button>
                    <button onclick="handleStatusChange('${item.time}', 'empty')"
                        ${item.status === 'empty' ? 'style="background:#b7f5b7;color:black"' : ''}>
                        ç©ºä½
                    </button>
                    <button onclick="startPhotoCapture('${item.time}')">æ‹ç…§</button>
                    ${item.photo ? `<button onclick="showPhoto('${item.time}')" style="color:blue;">ç…§ç‰‡</button>` : ''}
                    <button onclick="handleStatusChange('${item.time}', 'delete')" style="color:red">åˆªé™¤</button>
                </div>
            </div>
            `;
        }).join('');
        console.log("loadHistory() completed. Filtered items rendered:", filtered.length);
    }

    function initSound() {
        soundEnabled = localStorage.getItem(SOUND_KEY) === "true";
        updateSoundButton();
    }

    function toggleSound() {
        soundEnabled = !soundEnabled;
        localStorage.setItem(SOUND_KEY, soundEnabled);
        updateSoundButton();
        if (soundEnabled) playBeep();
    }

    function updateSoundButton() {
        soundBtn.textContent = soundEnabled ? "ğŸ”Š éŸ³æ•ˆé–‹å•Ÿ" : "ğŸ”‡ éŸ³æ•ˆé—œé–‰";
        soundBtn.style.backgroundColor = soundEnabled ? "#d4edda" : "#f8d7da";
    }

    function playBeep() {
        if (!soundEnabled) return;
        try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            osc.type = "sine";
            osc.frequency.value = 880;
            osc.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.1);
        } catch (err) {
            console.error("éŸ³æ•ˆæ’­æ”¾å¤±æ•—:", err);
        }
    }

    function exportCSV() {
        const list = getHistoryList();
        if (list.length === 0) return alert("æ²’æœ‰å¯å°å‡ºçš„æ•¸æ“š");

        // åŒ…å«å‚™è¨»æ¬„ä½
        const headers = ["å…§å®¹", "æ™‚é–“", "ç‹€æ…‹", "æ˜¯å¦æœ‰ç…§ç‰‡", "å‚™è¨»"];

        const rows = list.map(item => [
            `"${item.data.replace(/"/g, '""')}"`,
            `"${formatTime(item.time)}"`,
            `"${getStatusText(item.status)}"`,
            `"${item.photo ? 'Y' : 'N'}"`,
            `"${(item.remark || "").replace(/"/g, '""')}"` // ç¢ºä¿å‚™è¨»ä¹Ÿæ­£ç¢ºåŒ¯å‡ºï¼Œè™•ç†å¯èƒ½ç‚º undefined çš„æƒ…æ³
        ]);

        const csvContent = [
            headers.join(","),
            ...rows.map(row => row.join(","))
        ].join("\r\n");

        const blob = new Blob(["\uFEFF" + csvContent], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `å±¤æ¶è¨˜éŒ„_${new Date().toISOString().slice(0, 10)}.csv`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function getHistoryList() {
        const data = localStorage.getItem(STORAGE_KEY);
        return data ? JSON.parse(data) : [];
    }

    function saveHistoryList(list) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(list));
    }

    function formatTime(isoString) {
        const date = new Date(isoString);
        // é¡¯ç¤ºç‚º "YYYY/MM/DD HH:MM"
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.getDate().toString().padStart(2, '0');
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        return `${year}/${month}/${day} ${hours}:${minutes}`;
    }

    function getStatusText(status) {
        const map = {
            restock: "è£œè²¨",
            empty: "ç©ºä½"
        };
        return map[status] || "";
    }

    // Make functions globally accessible for inline event handlers
    window.handleStatusChange = handleStatusChange;
    window.startPhotoCapture = startPhotoCapture;
    window.showPhoto = showPhoto;
  </script>
</body>
</html>