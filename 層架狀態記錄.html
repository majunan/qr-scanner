<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>å±¤æ¶ç‹€æ…‹è¨˜éŒ„ï¼ˆçœŸç«™/æ¨¹æ—ï¼‰</title>
  <script src="https://unpkg.com/@zxing/library@0.19.1"></script>
  <style>
    /* --- é€šç”¨æ¨£å¼èˆ‡éŸ¿æ‡‰å¼åŸºç¤ --- */
    body {
      font-family: sans-serif;
      padding: 10px;
      margin: 0 auto;
      max-width: 650px;
      line-height: 1.6;
      color: #333;
      overflow: auto !important;
      position: relative;
    }
    
    /* iOS å°ˆç”¨æç¤ºæ¢ - æ”¹å–„ç‰ˆ */
    #iosAudioHint {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: linear-gradient(135deg, #ff6b6b, #ffa500);
      padding: 15px;
      text-align: center;
      z-index: 9999;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      color: white;
      font-weight: bold;
      animation: pulseHint 3s infinite;
      cursor: pointer;
      user-select: none;
    }
    
    @keyframes pulseHint {
      0% { 
        background: linear-gradient(135deg, #ff6b6b, #ffa500);
        transform: scale(1);
      }
      50% { 
        background: linear-gradient(135deg, #ff4757, #ff6348);
        transform: scale(1.02);
      }
      100% { 
        background: linear-gradient(135deg, #ff6b6b, #ffa500);
        transform: scale(1);
      }
    }
    
    #iosAudioHint .main-text {
      font-size: 1.1em;
      margin-bottom: 5px;
    }
    
    #iosAudioHint .sub-text {
      font-size: 0.9em;
      font-weight: normal;
      opacity: 0.9;
    }
    
    #iosAudioHint.success {
      background: linear-gradient(135deg, #2ed573, #1e90ff) !important;
      animation: successFade 2s ease-out forwards;
    }
    
    @keyframes successFade {
      0% { opacity: 1; transform: translateY(0); }
      70% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-100%); }
    }

    h1, h2 {
      margin-top: 20px;
      color: #2c3e50;
    }

    button {
      margin: 5px;
      padding: 10px 15px;
      font-size: 1.1em;
      cursor: pointer;
      border: 1px solid #ccc;
      border-radius: 4px;
      transition: all 0.3s ease;
      flex-shrink: 0;
    }
    button:hover:enabled {
        background-color: #e9e9e9;
        transform: translateY(-1px);
    }
    button:disabled {
        background-color: #e0e0e0;
        cursor: not-allowed;
        color: #888;
    }
    
    button[onclick^="startPhotoCapture"] {
      border: 2px solid #007bff !important;
    }
    
    select {
      padding: 8px 10px;
      font-size: 1.1em;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    #reader {
      position: relative;
      width: 9.2cm;
      height: 6.9cm;
      margin: 20px auto;
      object-fit: cover;
      overflow: hidden;
      border: 2px solid #333;
      display: block;
      background-color: #000;
    }

    .record {
      border-bottom: 1px solid #eee;
      padding: 8px 12px;
      margin-bottom: 5px;
      background-color: #fcfcfc;
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }

    .content-and-time {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
    }

    .record strong {
      font-size: 1.15em;
      word-break: break-all;
      flex-grow: 1;
      min-width: 0;
    }
    .record .time {
      font-size: 0.85em;
      color: #777;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .options {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: flex-start;
    }
    .options button {
      margin: 0;
      padding: 8px 12px;
      font-size: 0.95em;
    }
    .options button[style*="background:#ffa500"],
    .options button[style*="background:#b7f5b7"] {
        border-color: transparent;
    }

    .remark-section {
        margin-top: 15px;
        width: 90%;
        max-width: 500px;
        color: white;
    }
    .remark-section label {
        font-size: 0.9em;
        color: #ddd;
        display: block;
        margin-bottom: 3px;
    }
    .remark-input-container {
        display: flex;
        align-items: flex-end;
        gap: 5px;
    }
    .remark-section textarea {
        flex-grow: 1;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 0.95em;
        resize: none;
        min-height: 35px;
        max-height: none !important;
        box-sizing: border-box;
        background-color: #333;
        color: white;
        overflow-y: hidden !important;
        min-width: 0;
        height: auto;
        line-height: 1.2;
    }
    #clearRemarkBtn {
        padding: 8px 10px;
        font-size: 0.85em;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        align-self: flex-end;
        height: 35px;
        margin: 0;
    }
    #clearRemarkBtn:hover {
        background-color: #e64a19;
    }

    #remarkCharCount {
        font-size: 0.8em;
        color: #aaa;
        text-align: right;
        width: 100%;
        margin-top: 2px;
    }

    .filter-stats-container {
        display: flex !important;
        flex-wrap: wrap;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #eee;
    }
    .filter-stats-container label {
        font-weight: bold;
        color: #555;
        font-size: 1.1em;
    }
    #statusStats {
        font-size: 1.1em;
        color: #444;
        margin-left: 0;
        white-space: nowrap;
    }

    @media (min-width: 600px) {
      .filter-stats-container {
        flex-wrap: nowrap;
        border-bottom: 3px double #ccc;
      }
      .filter-stats-container label {
        margin-right: 10px;
      }
      #statusStats {
        margin-left: auto;
        margin-top: 0;
        border-bottom: none;
      }
      .options button {
          padding: 6px 12px;
          font-size: 1em;
      }
    }

    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      padding: 10px;
      box-sizing: border-box;
      overflow-y: auto;
    }
    .modal-video-preview {
      width: 90%;
      max-width: 500px;
      height: auto;
      max-height: 70vh;
      object-fit: cover;
      background-color: #000;
      border: 2px solid white;
    }
    .modal-controls {
        margin-top: 20px;
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        justify-content: center;
    }
    .modal-controls button {
      padding: 12px 25px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1.1em;
    }
    .btn-cancel {
        background: #f44336;
        color: white;
    }
    .modal-controls .btn-capture {
        background: #4CAF50;
        color: white;
        border: 2px solid yellow;
    }
    .btn-save {
        background: #007bff;
        color: white;
    }

    .flashlight-btn {
        background-color: #333;
        color: white;
        border: 2px solid #ffcc00;
    }
    .flashlight-btn.active {
        background-color: #ffcc00;
        color: black;
        font-weight: bold;
    }

    #photoDisplayModal {
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 10px;
    }
    #doodleCanvas {
        max-width: 95%;
        max-height: 60vh;
        border: 2px solid white;
        background-color: #000;
        touch-action: none;
    }
    .doodle-controls {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
        align-items: center;
    }
    .doodle-controls input[type="color"] {
        width: 40px;
        height: 40px;
        border: none;
        padding: 0;
        cursor: pointer;
    }
    .doodle-controls button {
        padding: 8px 12px;
        font-size: 0.95em;
    }

    #photoCanvas { display: none; }

    .scanner-header {
      display: flex !important;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .scanner-controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
    }

    /* æƒæå¼•å°æ¡† */
    #scanGuide {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 48%;
      height: 4cm;
      border: 3px solid #4CAF50;
      transition: border-color 0.3s;
      box-shadow: 0 0 15px 5px rgba(255, 255, 0, 0.9);
      pointer-events: none;
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }
    
    #scanGuide.camera-off {
      border-color: #ff0000;
      box-shadow: 0 0 10px rgba(255,0,0,0.5);
    }
    
    .guide-text {
      color: white;
      text-align: center;
    }
    
    .inactive-guide {
      display: none;
      font-size: 1.5em;
      color: white;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      text-align: center;
      margin: 0;
      padding: 0;
      line-height: 1.2;
    }
    
    .active-guide {
      font-size: 2.5em;
      color: #4CAF50;
      line-height: 1;
    }
    .active-guide div {
      font-size: 0.8em;
      margin-top: 10px;
    }

    /* è‡ªå®šç¾©åˆªé™¤ç¢ºèªå°è©±æ¡†æ¨£å¼ */
    .delete-confirm-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 3000;
    }
    .delete-confirm-content {
      background: white;
      padding: 20px;
      border-radius: 5px;
      max-width: 80%;
      text-align: center;
    }
    .delete-confirm-buttons {
      margin-top: 15px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .delete-confirm-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1em;
    }
    .delete-confirm-btn.confirm {
      background: #f44336;
      color: white;
    }
    .delete-confirm-btn.cancel {
      background: #ccc;
    }

    #resultList {
      display: block !important;
      position: relative;
      z-index: 5;
    }
    
    /* é¡¶éƒ¨æŒ‰é’®å®¹å™¨ */
    .top-buttons {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 10px;
    }

    /* éŸ³æ•ˆç‹€æ…‹æŒ‡ç¤ºå™¨ */
    .audio-status {
      position: relative;
      overflow: hidden;
    }
    
    .audio-status::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
      transition: left 0.5s;
    }
    
    .audio-status.unlocked::after {
      left: 100%;
    }
  </style>
</head>
<body>
  <!-- iOS å°ˆç”¨æç¤ºæ¢ - æ”¹å–„ç‰ˆ -->
  <div id="iosAudioHint">
    <div class="main-text">ğŸ”Š é»æ“Šæ­¤è™•å•Ÿç”¨beepéŸ³æ•ˆ</div>
    <div class="sub-text">iOSç³»çµ±éœ€è¦ç”¨æˆ¶äº¤äº’æ‰èƒ½æ’­æ”¾éŸ³æ•ˆ</div>
  </div>
  
  <h1>ğŸ“‹ å±¤æ¶ç‹€æ…‹è¨˜éŒ„</h1>
  
  <!-- é¡¶éƒ¨æŒ‰é’®å®¹å™¨ -->
  <div class="top-buttons">
    <button id="soundBtn" class="audio-status">ğŸ”‡ éŸ³æ•ˆé—œé–‰</button>
    <button id="exportBtn">ğŸ“¤ åŒ¯å‡ºè³‡æ–™</button>
  </div>

  <div id="reader-container" style="position: relative; width: 9.2cm; height: 6.9cm; margin: 20px auto;">
  <video id="reader" autoplay playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
  <div id="scanGuide">
    <div class="guide-text active-guide">
     âŠ•
    </div>
    <div class="guide-text inactive-guide">
      è«‹é–‹å•Ÿé¡é ­ï¼
    </div>
  </div>
</div>

  <div class="scanner-header">
    <h2>ğŸ“· æƒæè¨˜éŒ„</h2>
    <button id="toggleScannerBtn">é—œé–‰é¡é ­</button>
  </div>

  <div class="filter-stats-container">
    <label for="statusFilter">ç¯©é¸ç‹€æ…‹:</label>
    <select id="statusFilter">
      <option value="">å…¨éƒ¨ç‹€æ…‹</option>
      <option value="restock">è£œè²¨</option>
      <option value="empty">ç©ºä½</option>
    </select>
    <div id="statusStats"></div>
  </div>

  <div id="resultList"></div>

  <div id="photoCaptureModal" class="modal">
    <video id="photoCapturePreview" class="modal-video-preview" autoplay playsinline></video>
    <canvas id="photoCanvas"></canvas>
    <div class="modal-controls">
        <button id="captureBtn" class="btn-capture" disabled>æ‹ç…§</button>
        <button id="photoCaptureFlashBtn" class="flashlight-btn">ğŸ”¦ é–‹å•Ÿé–ƒå…‰ç‡ˆ</button>
        <button id="photoCaptureCancel" class="btn-cancel">å–æ¶ˆ</button>
    </div>
  </div>

  <div id="photoDisplayModal" class="modal">
      <canvas id="doodleCanvas"></canvas>
      <div class="doodle-controls">
          <input type="color" id="doodleColor" value="#FF0000">
          <button id="clearDoodleBtn">æ¸…é™¤å¡—é´‰</button>
          <button id="closeDoodleBtn" class="btn-cancel">é—œé–‰</button>
      </div>
      <div class="remark-section">
          <label for="modalRemarkTextarea">å‚™è¨»:</label>
          <div class="remark-input-container">
              <textarea id="modalRemarkTextarea"></textarea>
              <button id="clearRemarkBtn">æ¸…é™¤</button>
          </div>
          <span id="remarkCharCount"></span>
      </div>
  </div>

  <script>
    // ===== å¸¸æ•¸å®šç¾© =====
    const STORAGE_KEY = "shelf-scan-history";
    const SOUND_KEY = "sound-enabled";
    const AUDIO_UNLOCKED_KEY = "audio-unlocked";
    const REMARK_MAX_LENGTH = 120;
    const REMARK_MIN_HEIGHT = '35px';
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                 (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // ===== DOM å…ƒç´  =====
    const resultList = document.getElementById("resultList");
    const statusFilter = document.getElementById("statusFilter");
    const statusStats = document.getElementById("statusStats");
    const exportBtn = document.getElementById("exportBtn");
    const soundBtn = document.getElementById("soundBtn");
    const toggleScannerBtn = document.getElementById("toggleScannerBtn");
    const scanGuide = document.getElementById("scanGuide");
    const iosAudioHint = document.getElementById("iosAudioHint");

    // æ‹ç…§æ¨¡æ…‹è¦–çª—å…ƒç´ 
    const photoCaptureModal = document.getElementById("photoCaptureModal");
    const photoCapturePreview = document.getElementById("photoCapturePreview");
    const photoCanvas = document.getElementById("photoCanvas");
    const captureBtn = document.getElementById("captureBtn");
    const photoCaptureCancel = document.getElementById("photoCaptureCancel");
    const photoCaptureFlashBtn = document.getElementById("photoCaptureFlashBtn");

    // ç…§ç‰‡é¡¯ç¤ºæ¨¡æ…‹è¦–çª—å…ƒç´ 
    const photoDisplayModal = document.getElementById("photoDisplayModal");
    const doodleCanvas = document.getElementById("doodleCanvas");
    const doodleCtx = doodleCanvas.getContext('2d');
    const doodleColorInput = document.getElementById("doodleColor");
    const clearDoodleBtn = document.getElementById("clearDoodleBtn");
    const closeDoodleBtn = document.getElementById("closeDoodleBtn"); 
    const modalRemarkTextarea = document.getElementById("modalRemarkTextarea");
    const clearRemarkBtn = document.getElementById("clearRemarkBtn");
    const remarkCharCount = document.getElementById("remarkCharCount");

    // ===== ç‹€æ…‹è®Šæ•¸ =====
    let currentScanner = null;
    let currentPhotoTargetTime = null;
    let soundEnabled = false;
    let lastScanTimeMap = {};
    let photoStream = null;
    let scannerActive = true;
    let photoFlashActive = false;
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let originalPhotoDataUrl = null;
    let beepAudio = null;
    let audioUnlocked = false;
    let audioContext = null;

    // ===== åˆå§‹åŒ– =====
    document.addEventListener('DOMContentLoaded', function() {
      try {
        // æª¢æŸ¥éŸ³æ•ˆè§£é–ç‹€æ…‹
        audioUnlocked = localStorage.getItem(AUDIO_UNLOCKED_KEY) === 'true';
        
        // å¦‚æœæ˜¯iOSä¸”éŸ³æ•ˆå°šæœªè§£é–ï¼Œé¡¯ç¤ºæç¤º
        if (isIOS && !audioUnlocked) {
          iosAudioHint.style.display = 'block';
          // æ·»åŠ è„ˆå‹•æ•ˆæœ
          setTimeout(() => {
            iosAudioHint.style.transform = 'scale(1.05)';
            setTimeout(() => {
              iosAudioHint.style.transform = 'scale(1)';
            }, 200);
          }, 500);
        }
        
        initSound();
        loadHistory();
        startMainScanner();
        
        // å¼·åˆ¶é¡¯ç¤ºæ‰€æœ‰å¿…è¦å…ƒç´ 
        document.querySelectorAll('#resultList, .filter-stats-container, .scanner-header')
          .forEach(el => {
            el.style.display = 'block';
            el.style.visibility = 'visible';
          });
        
        // äº‹ä»¶ç›£è½å™¨
        statusFilter.addEventListener('change', loadHistory);
        exportBtn.addEventListener('click', exportCSV);
        soundBtn.addEventListener('click', handleSoundButtonClick);
        captureBtn.addEventListener('click', capturePhoto);
        photoCaptureCancel.addEventListener('click', cancelPhotoCapture);
        toggleScannerBtn.addEventListener('click', toggleScanner);
        photoCaptureFlashBtn.addEventListener('click', togglePhotoFlash);
        
        // iOS éŸ³æ•ˆè§£é–äº‹ä»¶ - æ”¹å–„ç‰ˆ
        iosAudioHint.addEventListener('click', unlockIOSAudio);
        iosAudioHint.addEventListener('touchstart', function(e) {
          e.preventDefault();
          unlockIOSAudio();
        });

        // å¡—é´‰äº‹ä»¶
        setupDoodleEvents();
        
        // å‚™è¨»æ¡†äº‹ä»¶  
        modalRemarkTextarea.addEventListener('input', handleRemarkInput);
        modalRemarkTextarea.addEventListener('blur', autoResizeRemarkTextarea);
        clearRemarkBtn.addEventListener('click', clearRemark);

        // åˆå§‹åŒ–å‚™è¨»æ¡†
        modalRemarkTextarea.placeholder = `è¼¸å…¥å‚™è¨» (æœ€å¤š ${REMARK_MAX_LENGTH} å­—)`;
        modalRemarkTextarea.setAttribute('maxlength', REMARK_MAX_LENGTH);
        updateRemarkCharCount();

        // å…¨å±€é»æ“Šç›£è½ - åƒ…åœ¨éœ€è¦æ™‚å•Ÿç”¨
        if (isIOS && !audioUnlocked) {
          document.addEventListener('click', globalAudioUnlockHandler, { once: false });
          document.addEventListener('touchstart', globalAudioUnlockHandler, { once: false });
        }

      } catch (error) {
        console.error("åˆå§‹åŒ–å¤±æ•—:", error);
        alert("ç¨‹å¼åˆå§‹åŒ–éŒ¯èª¤ï¼Œè«‹åˆ·æ–°é é¢ã€‚éŒ¯èª¤è©³æƒ…: " + error.message);
      }
    });

    // ===== éŸ³æ•ˆç³»çµ± - æ”¹å–„ç‰ˆ ===== 
    function initSound() {
      try {
        soundEnabled = localStorage.getItem(SOUND_KEY) === "true";
        
        // å‰µå»ºéŸ³æ•ˆè³‡æº
        createAudioResources();
        
        updateSoundButton();
        
        // éiOSè¨­å‚™æˆ–å·²è§£é–çš„iOSè¨­å‚™
        if (!isIOS || audioUnlocked) {
          enableAudioFeatures();
        }
        
      } catch (e) {
        console.error("éŸ³æ•ˆåˆå§‹åŒ–å¤±æ•—:", e);
      }
    }

    function createAudioResources() {
      // å„ªå…ˆå˜—è©¦ä½¿ç”¨Web Audio APIç”Ÿæˆæ¸…è„†çš„beepéŸ³æ•ˆ
      if (window.AudioContext || window.webkitAudioContext) {
        try {
          // ä½¿ç”¨Web Audio APIæ™‚ä¸éœ€è¦é å…ˆå‰µå»ºAudioå…ƒç´ 
          console.log('å°‡ä½¿ç”¨Web Audio APIç”ŸæˆbeepéŸ³æ•ˆ');
          return;
        } catch (e) {
          console.warn('Web Audio APIåˆå§‹åŒ–å¤±æ•—ï¼Œé™ç´šä½¿ç”¨éŸ³æ•ˆæª”æ¡ˆ');
        }
      }
      
      // å‚™ç”¨æ–¹æ¡ˆï¼šå‰µå»ºéŸ³æ•ˆæª”æ¡ˆ
      beepAudio = new Audio();
      beepAudio.preload = 'auto';
      
      // ä½¿ç”¨æ›´å¥½è½çš„beepéŸ³æ•ˆ - æ¸…è„†çŸ­ä¿ƒçš„èœ‚é³´è²
      beepAudio.src = 'data:audio/wav;base64,UklGRvIBAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YU4BAABEsM7/2LUfPn8OAI9OwIjAOkFBQdWOsgJLPKpEP39EQnRERHJERHrRQOjRBAYGBoxhJJCQkOBwYOD4gOBUcU4RJJCRQMCA4GBg4FhxYhklGhYGAoywgICAgKCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCAoJCC';
      
      beepAudio.addEventListener('canplaythrough', function() {
        console.log('beepéŸ³æ•ˆè³‡æºè¼‰å…¥å®Œæˆ');
      });
      
      beepAudio.addEventListener('error', function(e) {
        console.warn('å…§å»ºbeepéŸ³æ•ˆå¤±æ•—ï¼Œå˜—è©¦è¼‰å…¥å¤–éƒ¨æª”æ¡ˆ');
        // å‚™ç”¨æ–¹æ¡ˆï¼šè¼‰å…¥å¤–éƒ¨æª”æ¡ˆ
        beepAudio.src = 'beep.mp3';
      });
    }

    function enableAudioFeatures() {
      if (audioUnlocked) return;
      
      try {
        // å‰µå»º AudioContext ï¼ˆå¦‚æœæ”¯æ´ï¼‰
        if (window.AudioContext || window.webkitAudioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        audioUnlocked = true;
        localStorage.setItem(AUDIO_UNLOCKED_KEY, 'true');
        
        console.log('éŸ³æ•ˆåŠŸèƒ½å·²å•Ÿç”¨');
        
        // ç§»é™¤å…¨å±€ç›£è½å™¨
        document.removeEventListener('click', globalAudioUnlockHandler);
        document.removeEventListener('touchstart', globalAudioUnlockHandler);
        
      } catch (e) {
        console.error('éŸ³æ•ˆå•Ÿç”¨å¤±æ•—:', e);
      }
    }

    async function unlockIOSAudio() {
      if (audioUnlocked) return;
      
      try {
        // é¡¯ç¤ºè¼‰å…¥ç‹€æ…‹
        iosAudioHint.innerHTML = '<div class="main-text">ğŸ”„ æ­£åœ¨å•Ÿç”¨beepéŸ³æ•ˆ...</div>';
        
        // åˆå§‹åŒ–AudioContextï¼ˆå¦‚æœæ”¯æ´ï¼‰
        if (window.AudioContext || window.webkitAudioContext) {
          if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          if (audioContext.state === 'suspended') {
            await audioContext.resume();
          }
          
          // æ’­æ”¾æ¸¬è©¦beepéŸ³æ•ˆ
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
          
          gainNode.gain.setValueAtTime(0, audioContext.currentTime);
          gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.1);
          
          console.log('Web Audio beepè§£é–æˆåŠŸ');
        }
        
        // å˜—è©¦æ’­æ”¾HTML5éŸ³æ•ˆä½œç‚ºå‚™ç”¨
        if (beepAudio) {
          beepAudio.muted = true;
          beepAudio.volume = 0;
          
          const playPromise = beepAudio.play();
          
          if (playPromise !== undefined) {
            await playPromise;
            beepAudio.pause();
            beepAudio.currentTime = 0;
            beepAudio.muted = false;
            beepAudio.volume = 0.6;
          }
        }
        
        // æ¨™è¨˜ç‚ºå·²è§£é–
        audioUnlocked = true;
        localStorage.setItem(AUDIO_UNLOCKED_KEY, 'true');
        
        // é¡¯ç¤ºæˆåŠŸè¨Šæ¯
        iosAudioHint.classList.add('success');
        iosAudioHint.innerHTML = '<div class="main-text">âœ… beepéŸ³æ•ˆå·²å•Ÿç”¨ï¼</div>';
        
        // æ’­æ”¾æ¸¬è©¦éŸ³æ•ˆ
        if (soundEnabled) {
          setTimeout(() => playBeep(), 300);
        }
        
        // æ›´æ–°éŸ³æ•ˆæŒ‰éˆ•ç‹€æ…‹
        updateSoundButton();
        
        // 2ç§’å¾Œéš±è—æç¤º
        setTimeout(() => {
          iosAudioHint.style.display = 'none';
        }, 2000);
        
        // ç§»é™¤å…¨å±€ç›£è½å™¨
        document.removeEventListener('click', globalAudioUnlockHandler);
        document.removeEventListener('touchstart', globalAudioUnlockHandler);
        
        console.log('iOS beepéŸ³æ•ˆè§£é–æˆåŠŸ');
        
      } catch (error) {
        console.error('iOS beepéŸ³æ•ˆè§£é–å¤±æ•—:', error);
        
        // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
        iosAudioHint.classList.remove('success');
        iosAudioHint.innerHTML = `
          <div class="main-text">âŒ beepéŸ³æ•ˆå•Ÿç”¨å¤±æ•—</div>
          <div class="sub-text">è«‹å˜—è©¦é»æ“Šå…¶ä»–æŒ‰éˆ•</div>
        `;
        iosAudioHint.style.background = 'linear-gradient(135deg, #ff4757, #c44569)';
        
        // 3ç§’å¾Œæ¢å¾©åŸå§‹æç¤º
        setTimeout(() => {
          iosAudioHint.classList.remove('success');
          iosAudioHint.style.background = '';
          iosAudioHint.innerHTML = `
            <div class="main-text">ğŸ”Š é»æ“Šæ­¤è™•å•Ÿç”¨beepéŸ³æ•ˆ</div>
            <div class="sub-text">iOSç³»çµ±éœ€è¦ç”¨æˆ¶äº¤äº’æ‰èƒ½æ’­æ”¾éŸ³æ•ˆ</div>
          `;
        }, 3000);
      }
    }

    function globalAudioUnlockHandler(e) {
      // åªåœ¨é»æ“ŠæŒ‰éˆ•æˆ–é‡è¦å…ƒç´ æ™‚å˜—è©¦è§£é–
      if (e.target.tagName === 'BUTTON' || 
          e.target.closest('button') || 
          e.target.id === 'iosAudioHint') {
        unlockIOSAudio();
      }
    }

    function handleSoundButtonClick() {
      // å¦‚æœæ˜¯iOSä¸”æœªè§£é–ï¼Œå…ˆå˜—è©¦è§£é–
      if (isIOS && !audioUnlocked) {
        unlockIOSAudio().then(() => {
          toggleSound();
        });
      } else {
        toggleSound();
      }
    }

    function toggleSound() {
      soundEnabled = !soundEnabled;
      localStorage.setItem(SOUND_KEY, soundEnabled);
      updateSoundButton();
      
      // æ’­æ”¾æ¸¬è©¦éŸ³æ•ˆ
      if (soundEnabled && audioUnlocked) {
        setTimeout(() => playBeep(), 100);
      }
    }

    function updateSoundButton() {
      const isUnlocked = !isIOS || audioUnlocked;
      
      if (soundEnabled && isUnlocked) {
        soundBtn.textContent = "ğŸ”Š éŸ³æ•ˆé–‹å•Ÿ";
        soundBtn.style.backgroundColor = "#d4edda";
        soundBtn.classList.add('unlocked');
      } else if (soundEnabled && !isUnlocked) {
        soundBtn.textContent = "ğŸ”‡ éŸ³æ•ˆå¾…å•Ÿç”¨";
        soundBtn.style.backgroundColor = "#fff3cd";
      } else {
        soundBtn.textContent = "ğŸ”‡ éŸ³æ•ˆé—œé–‰";
        soundBtn.style.backgroundColor = "#f8d7da";
        soundBtn.classList.remove('unlocked');
      }
    }

    function playBeep() {
      if (!soundEnabled) return;
      
      // iOSç‰¹æ®Šè™•ç†
      if (isIOS && !audioUnlocked) {
        console.log('iOSéŸ³æ•ˆå°šæœªè§£é–ï¼Œè·³éæ’­æ”¾');
        return;
      }
      
      try {
        // å„ªå…ˆä½¿ç”¨Web Audio APIç”Ÿæˆæ¸…è„†çš„beepéŸ³æ•ˆ
        if ((window.AudioContext || window.webkitAudioContext) && audioContext) {
          playWebAudioBeep();
          return;
        }
        
        // å‚™ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨éŸ³æ•ˆæª”æ¡ˆ
        if (beepAudio) {
          // é‡ç½®æ’­æ”¾ä½ç½®
          beepAudio.currentTime = 0;
          beepAudio.volume = 0.6; // é™ä½éŸ³é‡é¿å…ééŸ¿
          
          const playPromise = beepAudio.play();
          
          if (playPromise !== undefined) {
            playPromise
              .then(() => {
                console.log('beepéŸ³æ•ˆæ’­æ”¾æˆåŠŸ');
              })
              .catch(error => {
                console.warn('beepéŸ³æ•ˆæ’­æ”¾å¤±æ•—:', error);
                
                // å¦‚æœæ˜¯iOSä¸”æ’­æ”¾å¤±æ•—ï¼Œæç¤ºç”¨æˆ¶è§£é–
                if (isIOS && !audioUnlocked) {
                  showAudioUnlockHint();
                }
              });
          }
        }
      } catch (error) {
        console.error('æ’­æ”¾beepéŸ³æ•ˆæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
      }
    }

    function playWebAudioBeep() {
      if (!audioContext) return;
      
      try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        // è¨­å®šbeepéŸ³æ•ˆåƒæ•¸
        oscillator.type = 'sine'; // æ­£å¼¦æ³¢ç”¢ç”Ÿæ¸…è„†éŸ³æ•ˆ
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // 800Hzé »ç‡
        
        // éŸ³é‡æ§åˆ¶ - å¿«é€Ÿæ·¡å…¥æ·¡å‡ºé¿å…çˆ†éŸ³
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01); // 10msæ·¡å…¥
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15); // 150msæ·¡å‡º
        
        // é€£æ¥éŸ³æ•ˆç¯€é»
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // æ’­æ”¾éŸ³æ•ˆ
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.15); // 150msæŒçºŒæ™‚é–“
        
        console.log('Web Audio beepæ’­æ”¾æˆåŠŸ');
        
      } catch (error) {
        console.error('Web Audio beepæ’­æ”¾å¤±æ•—:', error);
        // é™ç´šä½¿ç”¨éŸ³æ•ˆæª”æ¡ˆ
        if (beepAudio) {
          beepAudio.currentTime = 0;
          beepAudio.volume = 0.6;
          beepAudio.play().catch(e => console.warn('å‚™ç”¨éŸ³æ•ˆæ’­æ”¾å¤±æ•—:', e));
        }
      }
    }

    function showAudioUnlockHint() {
      if (iosAudioHint.style.display === 'none') {
        iosAudioHint.style.display = 'block';
        iosAudioHint.innerHTML = `
          <div class="main-text">ğŸ”Š éœ€è¦å•Ÿç”¨éŸ³æ•ˆ</div>
          <div class="sub-text">é»æ“Šæ­¤è™•è§£é–beepéŸ³æ•ˆåŠŸèƒ½</div>
        `;
      }
    }

    // ===== æƒæå™¨åŠŸèƒ½ =====
    async function startMainScanner() {
        stopAllStreams();
        try {
            // ç¢ºä¿ZXingåº«å·²è¼‰å…¥
            if (typeof ZXing === 'undefined') {
                throw new Error("ZXingæƒæåº«æœªæ­£ç¢ºè¼‰å…¥ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·š");
            }

            const hints = new Map();
            hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [ZXing.BarcodeFormat.QR_CODE]);

            currentScanner = new ZXing.BrowserMultiFormatReader(hints);
            await currentScanner.decodeFromVideoDevice(
                undefined,
                'reader',
                (result, err) => {
                    if (result) {
                        const now = Date.now();
                        const lastTime = lastScanTimeMap[result.text] || 0;
                        if (now - lastTime >= 5000) {
                            lastScanTimeMap[result.text] = now;
                            addHistory(result.text);
                        }
                    }
                    if (err && !(err instanceof ZXing.NotFoundException)) {
                        console.error(err);
                    }
                }
            );
            scannerActive = true;
            toggleScannerBtn.textContent = "é—œé–‰é¡é ­";
            // é¡¯ç¤ºæƒæå¼•å°æ¡†
            scanGuide.style.display = 'flex';
            scanGuide.classList.remove("camera-off");
            document.querySelector(".active-guide").style.display = "block";
            document.querySelector(".inactive-guide").style.display = "none";
        } catch (err) {
            console.error("æƒæå™¨åˆå§‹åŒ–å¤±æ•—:", err);
            scannerActive = false;
            toggleScannerBtn.textContent = "é–‹å•Ÿé¡é ­";
            // é¡¯ç¤ºé—œé–‰ç‹€æ…‹çš„æƒæå¼•å°æ¡†
            scanGuide.style.display = 'flex';
            scanGuide.classList.add("camera-off");
            document.querySelector(".active-guide").style.display = "none";
            document.querySelector(".inactive-guide").style.display = "block";
            
            // é¡¯ç¤ºå…·é«”éŒ¯èª¤è¨Šæ¯
            alert("æƒæå™¨å•Ÿå‹•å¤±æ•—: " + (err.message || "è«‹æª¢æŸ¥ç›¸æ©Ÿæ¬Šé™"));
        }
    }

    function stopMainScanner() {
      stopAllStreams();
      if (currentScanner) {
        currentScanner.reset();
        currentScanner = null;
      }
      scannerActive = false;
      toggleScannerBtn.textContent = "é–‹å•Ÿé¡é ­";
      // é¡¯ç¤ºé—œé–‰ç‹€æ…‹çš„æƒæå¼•å°æ¡†
      scanGuide.style.display = 'flex';
      scanGuide.classList.add("camera-off");
      document.querySelector(".active-guide").style.display = "none";
      document.querySelector(".inactive-guide").style.display = "block";
    }

    function toggleScanner() {
      if (scannerActive) {
        stopMainScanner();
      } else {
        startMainScanner();
      }
    }

    function stopAllStreams() {
        if (photoStream) {
            photoStream.getTracks().forEach(track => track.stop());
            photoStream = null;
        }
        if (currentScanner) {
            currentScanner.reset();
            currentScanner = null;
        }
    }

    // ===== è¨˜éŒ„ç®¡ç† =====
    function addHistory(data) {
        const list = getHistoryList();
        const existingRecord = list.find(item => item.data === data);
        const now = new Date().toISOString();
        let recordToScrollId = '';

        if (existingRecord) {
            existingRecord.time = now;
            existingRecord.status = "restock";
            recordToScrollId = `record-${existingRecord.time}`;
        } else {
            const newRecord = {
                data: data,
                time: now,
                status: "restock",
                photo: null,
                originalPhoto: null,
                remark: ""
            };
            list.unshift(newRecord);
            recordToScrollId = `record-${newRecord.time}`;
        }
        saveHistoryList(list);
        loadHistory();
        playBeep();

        setTimeout(() => {
            const element = document.getElementById(recordToScrollId);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }, 100);
    }

    async function handleStatusChange(time, status) {
        const list = getHistoryList();
        const recordIndex = list.findIndex(item => item.time === time);
        
        if (recordIndex !== -1) {
            if (status === "delete") {
                const confirmed = await confirmDelete(list[recordIndex].data);
                if (confirmed) {
                    list.splice(recordIndex, 1);
                    saveHistoryList(list);
                    loadHistory();
                }
            } else {
                list[recordIndex].status = status;
                saveHistoryList(list);
                loadHistory();
            }
        }
    }

    function confirmDelete(message) {
        return new Promise((resolve) => {
            const modal = document.createElement('div');
            modal.className = 'delete-confirm-modal';
            
            const content = document.createElement('div');
            content.className = 'delete-confirm-content';
            content.innerHTML = `
                <p>ç¢ºå®šåˆªé™¤è¨˜éŒ„: ${message}ï¼Ÿ</p>
                <div class="delete-confirm-buttons">
                    <button class="delete-confirm-btn confirm">ç¢ºå®š</button>
                    <button class="delete-confirm-btn cancel">å–æ¶ˆ</button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            const confirmBtn = content.querySelector('.confirm');
            const cancelBtn = content.querySelector('.cancel');
            
            confirmBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
                resolve(true);
            });
            
            cancelBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
                resolve(false);
            });
        });
    }

    function loadHistory() {
        const list = getHistoryList();
        const filter = statusFilter.value;
        const filtered = filter ? list.filter(item => item.status === filter) : list;

        const stats = {
            restock: list.filter(item => item.status === "restock").length,
            empty: list.filter(item => item.status === "empty").length,
        };

        statusStats.innerHTML = `
            è£œè²¨: ${stats.restock} |
            ç©ºä½: ${stats.empty}
        `;

        resultList.innerHTML = filtered.map(item => {
            return `
            <div class="record" id="record-${item.time}" data-time="${item.time}" data-status="${item.status}">
                <div class="content-and-time">
                    <strong>${item.data}</strong>
                    <div class="time">${formatTime(item.time)}</div>
                </div>
                <div class="options">
                    <button onclick="handleStatusChange('${item.time}', 'restock')"
                        ${item.status === 'restock' ? 'style="background:#ffa500;color:white"' : ''}>
                        è£œè²¨
                    </button>
                    <button onclick="handleStatusChange('${item.time}', 'empty')"
                        ${item.status === 'empty' ? 'style="background:#b7f5b7;color:black"' : ''}>
                        ç©ºä½
                    </button>
                    <button onclick="startPhotoCapture('${item.time}')">æ‹ç…§</button>
                    ${item.photo ? `<button onclick="showPhoto('${item.time}')" style="color:blue;">ç…§ç‰‡</button>` : ''}
                    <button onclick="handleStatusChange('${item.time}', 'delete')" style="color:red">åˆªé™¤</button>
                </div>
            </div>
            `;
        }).join('');
    }

    // ===== æ‹ç…§åŠŸèƒ½ =====
    async function startPhotoCapture(time) {
        currentPhotoTargetTime = time;
        stopAllStreams();
        photoCaptureModal.style.display = 'flex';
        try {
            photoStream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    facingMode: 'environment',
                    torch: photoFlashActive
                } 
            });
            photoCapturePreview.srcObject = photoStream;

            photoCapturePreview.onloadedmetadata = () => {
                photoCapturePreview.play().catch(err => console.error("å½±ç‰‡æ’­æ”¾å¤±æ•—:", err));
                captureBtn.disabled = false;
                photoCaptureFlashBtn.disabled = false;
            };

        } catch (err) {
            console.error("ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿ:", err);
            alert("ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿï¼Œè«‹æª¢æŸ¥æ¬Šé™æˆ–è£ç½®ã€‚\néŒ¯èª¤è¨Šæ¯: " + err.message);
            cancelPhotoCapture();
        }
    }

    function capturePhoto() {
        const context = photoCanvas.getContext('2d');
        photoCanvas.width = photoCapturePreview.videoWidth;
        photoCanvas.height = photoCapturePreview.videoHeight;
        context.drawImage(photoCapturePreview, 0, 0, photoCanvas.width, photoCanvas.height);

        const dataUrl = photoCanvas.toDataURL('image/jpeg', 0.8);
        const list = getHistoryList();
        const record = list.find(item => item.time === currentPhotoTargetTime);

        if (record) {
            record.photo = dataUrl;
            record.originalPhoto = dataUrl;
            saveHistoryList(list);
            playBeep();
        }

        photoCaptureModal.style.display = 'none';
        stopAllStreams();
        startMainScanner();
        showPhoto(currentPhotoTargetTime);
    }

    function cancelPhotoCapture() {
        photoCaptureModal.style.display = 'none';
        currentPhotoTargetTime = null;
        captureBtn.disabled = true;
        photoCaptureFlashBtn.disabled = true;
        if (photoStream) {
            photoStream.getTracks().forEach(track => track.stop());
            photoStream = null;
        }
        photoCapturePreview.srcObject = null;
        photoFlashActive = false;
        photoCaptureFlashBtn.classList.remove('active');
        photoCaptureFlashBtn.textContent = "ğŸ”¦ é–‹å•Ÿé–ƒå…‰ç‡ˆ";
        startMainScanner();
        loadHistory();
        setTimeout(() => {
            if (resultList.firstElementChild) {
                resultList.firstElementChild.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }, 100);
    }

    async function togglePhotoFlash() {
        if (!photoStream) return;
        
        try {
            const videoTrack = photoStream.getVideoTracks()[0];
            if (!videoTrack) return;
            
            if (typeof videoTrack.getCapabilities === 'function') {
                const capabilities = videoTrack.getCapabilities();
                if (capabilities.torch) {
                    photoFlashActive = !photoFlashActive;
                    await videoTrack.applyConstraints({
                        advanced: [{torch: photoFlashActive}]
                    });
                    
                    photoCaptureFlashBtn.classList.toggle('active', photoFlashActive);
                    photoCaptureFlashBtn.textContent = photoFlashActive ? "ğŸ”¦ é—œé–‰é–ƒå…‰ç‡ˆ" : "ğŸ”¦ é–‹å•Ÿé–ƒå…‰ç‡ˆ";
                    photoCaptureFlashBtn.disabled = false;
                    return;
                }
            }
            
            alert("æ‚¨çš„è¨­å‚™ä¸æ”¯æ´é–ƒå…‰ç‡ˆåŠŸèƒ½");
            photoCaptureFlashBtn.disabled = true;
        } catch (err) {
            console.error("é–ƒå…‰ç‡ˆåˆ‡æ›å¤±æ•—:", err);
            alert("é–ƒå…‰ç‡ˆåˆ‡æ›å¤±æ•—: " + err.message);
            photoCaptureFlashBtn.disabled = true;
        }
    }

    // ===== ç…§ç‰‡é¡¯ç¤ºèˆ‡å¡—é´‰ =====
    function showPhoto(time) {
        const list = getHistoryList();
        const record = list.find(item => item.time === time);
        if (record && record.photo) {
            if (!record.originalPhoto) {
                record.originalPhoto = record.photo;
                saveHistoryList(list);
            }
            if (record.remark === undefined) {
                record.remark = "";
                saveHistoryList(list);
            }

            originalPhotoDataUrl = record.originalPhoto;

            const img = new Image();
            img.onload = () => {
                const maxWidth = window.innerWidth * 0.95;
                const maxHeight = window.innerHeight * 0.60;

                let width = img.width;
                let height = img.height;

                if (width > maxWidth) {
                    height = height * (maxWidth / width);
                    width = maxWidth;
                }
                if (height > maxHeight) {
                    width = width * (maxHeight / height);
                    height = maxHeight;
                }

                doodleCanvas.width = width;
                doodleCanvas.height = height;

                doodleCtx.clearRect(0, 0, doodleCanvas.width, doodleCanvas.height);
                doodleCtx.drawImage(img, 0, 0, doodleCanvas.width, doodleCanvas.height);
            };
            img.src = record.photo;
            
            modalRemarkTextarea.value = record.remark.substring(0, REMARK_MAX_LENGTH);
            autoResizeRemarkTextarea();
            updateRemarkCharCount();

            photoDisplayModal.style.display = 'flex';
            currentPhotoTargetTime = time;
        } else {
            alert("æ‰¾ä¸åˆ°ç…§ç‰‡!");
        }
    }

    function setupDoodleEvents() {
      doodleCanvas.addEventListener('mousedown', startDrawing);
      doodleCanvas.addEventListener('mousemove', draw);
      doodleCanvas.addEventListener('mouseup', stopDrawing);
      doodleCanvas.addEventListener('mouseout', stopDrawing);

      doodleCanvas.addEventListener('touchstart', startDrawing);
      doodleCanvas.addEventListener('touchmove', draw);
      doodleCanvas.addEventListener('touchend', stopDrawing);
      doodleCanvas.addEventListener('touchcancel', stopDrawing);

      clearDoodleBtn.addEventListener('click', clearDoodle); 
      
      clearDoodleBtn.addEventListener('touchstart', function(event) {
          event.preventDefault(); 
      });

      clearDoodleBtn.addEventListener('touchend', function(event) {
          event.preventDefault(); 
          clearDoodle(); 
      });

      closeDoodleBtn.addEventListener('click', closePhotoDisplay); 
      
      closeDoodleBtn.addEventListener('touchstart', function(event) {
          event.preventDefault(); 
      });

      closeDoodleBtn.addEventListener('touchend', function(event) {
          event.preventDefault(); 
          modalRemarkTextarea.blur(); 
          closePhotoDisplay(); 
      });
    }

    function startDrawing(e) {
        e.preventDefault();
        isDrawing = true;
        const pos = e.type.includes('mouse') ? getMousePos(doodleCanvas, e) : getTouchPos(doodleCanvas, e);
        [lastX, lastY] = [pos.x, pos.y];
        doodleCtx.beginPath();
        doodleCtx.moveTo(lastX, lastY);
    }

    function draw(e) {
        if (!isDrawing) return;
        e.preventDefault();
        const pos = e.type.includes('mouse') ? getMousePos(doodleCanvas, e) : getTouchPos(doodleCanvas, e);

        doodleCtx.lineWidth = 5;
        doodleCtx.lineCap = 'round';
        doodleCtx.strokeStyle = doodleColorInput.value;

        doodleCtx.lineTo(pos.x, pos.y);
        doodleCtx.stroke();
        [lastX, lastY] = [pos.x, pos.y];
    }

    function stopDrawing() {
        isDrawing = false;
        doodleCtx.closePath();
    }

    function clearDoodle() {
        if (originalPhotoDataUrl) {
            const img = new Image();
            img.onload = () => {
                doodleCtx.clearRect(0, 0, doodleCanvas.width, doodleCanvas.height);
                doodleCtx.drawImage(img, 0, 0, doodleCanvas.width, doodleCanvas.height);
            };
            img.src = originalPhotoDataUrl;
        } else {
            doodleCtx.clearRect(0, 0, doodleCanvas.width, doodleCanvas.height);
        }
    }

    function closePhotoDisplay() {
        if (currentPhotoTargetTime) { 
            const dataUrl = doodleCanvas.toDataURL('image/jpeg', 0.8);
            const list = getHistoryList();
            const record = list.find(item => item.time === currentPhotoTargetTime);

            if (record) {
                record.photo = dataUrl;
                saveHistoryList(list);
            }

            saveRemark(currentPhotoTargetTime, modalRemarkTextarea.value);
        }

        photoDisplayModal.style.display = 'none';
        doodleCtx.clearRect(0, 0, doodleCanvas.width, doodleCanvas.height);
        originalPhotoDataUrl = null;
        currentPhotoTargetTime = null;
        modalRemarkTextarea.value = '';
        modalRemarkTextarea.style.height = REMARK_MIN_HEIGHT;
        updateRemarkCharCount();

        loadHistory();
        setTimeout(() => {
            if (resultList.firstElementChild) {
                resultList.firstElementChild.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }, 100);
    }

    function getMousePos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (evt.clientX - rect.left) * scaleX,
            y: (evt.clientY - rect.top) * scaleY
        };
    }

    function getTouchPos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const touch = evt.touches[0];
        return {
            x: (touch.clientX - rect.left) * scaleX,
            y: (touch.clientY - rect.top) * scaleY
        };
    }

    // ===== å‚™è¨»åŠŸèƒ½ =====
    function handleRemarkInput() {
        if (modalRemarkTextarea.value.length > REMARK_MAX_LENGTH) {
            modalRemarkTextarea.value = modalRemarkTextarea.value.substring(0, REMARK_MAX_LENGTH);
        }
        autoResizeRemarkTextarea();
        updateRemarkCharCount();
    }

    function autoResizeRemarkTextarea() {
        modalRemarkTextarea.style.height = 'auto'; 
        modalRemarkTextarea.style.overflowY = 'hidden';

        window.requestAnimationFrame(() => {
            let newHeight = modalRemarkTextarea.scrollHeight;
            
            if (newHeight < parseFloat(REMARK_MIN_HEIGHT)) {
                newHeight = parseFloat(REMARK_MIN_HEIGHT);
            }

            modalRemarkTextarea.style.height = newHeight + 'px';
        });
    }

    function updateRemarkCharCount() {
        const currentLength = modalRemarkTextarea.value.length;
        remarkCharCount.textContent = `${currentLength}/${REMARK_MAX_LENGTH} å­—`;
        remarkCharCount.style.color = currentLength > REMARK_MAX_LENGTH ? '#ff5722' : '#aaa';
    }

    function clearRemark() {
        modalRemarkTextarea.value = '';
        autoResizeRemarkTextarea();
        updateRemarkCharCount();
        if (currentPhotoTargetTime) {
            saveRemark(currentPhotoTargetTime, '');
        }
    }

    function saveRemark(time, newRemarkValue) {
        const list = getHistoryList();
        const record = list.find(item => item.time === time);
        if (record) {
            record.remark = newRemarkValue.substring(0, REMARK_MAX_LENGTH);
            saveHistoryList(list);
        }
    }

    // ===== å·¥å…·å‡½æ•¸ =====
    function exportCSV() {
        const list = getHistoryList();
        if (list.length === 0) return alert("æ²’æœ‰å¯å°å‡ºçš„æ•¸æ“š");

        const headers = ["å…§å®¹", "æ™‚é–“", "ç‹€æ…‹", "æ˜¯å¦æœ‰ç…§ç‰‡", "å‚™è¨»"];

        const rows = list.map(item => [
            `"${item.data.replace(/"/g, '""')}"`,
            `"${formatTime(item.time)}"`,
            `"${getStatusText(item.status)}"`,
            `"${item.photo ? 'Y' : 'N'}"`,
            `"${(item.remark || "").replace(/"/g, '""')}"`
        ]);

        const csvContent = [
            headers.join(","),
            ...rows.map(row => row.join(","))
        ].join("\r\n");

        const blob = new Blob(["\uFEFF" + csvContent], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `å±¤æ¶è¨˜éŒ„_${new Date().toISOString().slice(0, 10)}.csv`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function getHistoryList() {
        const data = localStorage.getItem(STORAGE_KEY);
        return data ? JSON.parse(data) : [];
    }

    function saveHistoryList(list) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(list));
    }

    function formatTime(isoString) {
        const date = new Date(isoString);
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.getDate().toString().padStart(2, '0');
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        return `${year}/${month}/${day} ${hours}:${minutes}`;
    }

    function getStatusText(status) {
        const map = {
            restock: "è£œè²¨",
            empty: "ç©ºä½"
        };
        return map[status] || "";
    }

    // ===== å…¨å±€å‡½æ•¸ =====
    window.handleStatusChange = handleStatusChange;
    window.startPhotoCapture = startPhotoCapture;
    window.showPhoto = showPhoto;
  </script>
</body>
</html>